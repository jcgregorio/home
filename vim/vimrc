" .vimrc
" Author: joe@bitworking.org
" Source: https://joe.gregorio@code.google.com/p/jcgregorio/vim
" Make sure to link $HOME/.vimrc to this vimrc
" Also install vim-pathogen, and then syntastic, and UltiSnips.
" To get 256 colors just set TERM=gnome-256color in .bashrc, because
" we always use gnome-terminal, so all the fancy detection stuff is a waste.
" After running sudo apt-get install ncurses-term.
"
set incsearch
syntax on
set hlsearch
set tabstop=2
set softtabstop=2
set expandtab
set shiftwidth=2
set nowrap
set diffopt=filler,iwhite
set ignorecase
set smartcase
set textwidth=78
set autoindent

set rtp+=$HOME/jcgregorio/vim
set t_Co=256
colorscheme desert256

execute pathogen#infect()

" Make tab completion work more like the shell.
set wildmode=longest,list

" Set the font.
set guifont=DejaVu\ Sans\ Mono\ 7

" Remove bling.
set guioptions-=T
set guioptions-=m

" Guard against weirdness if your shell starts launcing as an interactive.
set shell=/bin/bash\ -l

" For all text files set 'textwidth' to 78 characters.
autocmd FileType text setlocal textwidth=78

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid or when inside an event handler
" (happens when dropping a file on gvim).
autocmd BufReadPost *
  \ if line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g`\"" |
  \ endif

" CSS {{{
au BufNewFile,BufRead *.gss set filetype=css
" }}}

" Go {{{
" Import syntax highlighting and other goodies for Go.
set rtp+=$HOME/go/misc/vim
filetype plugin on
autocmd FileType go autocmd BufWritePre <buffer> Fmt
autocmd FileType go set textwidth=0
" }}}

" C++ {{{
filetype plugin on
autocmd FileType cpp set tabstop=4
autocmd FileType cpp set softtabstop=4
autocmd FileType cpp set shiftwidth=4
" }}}


" Backups {{{
set backupdir=~/.vim/tmp/backup// " backups
set directory=~/.vim/tmp/swap//   " swap files
set backup                        " enable backups
" }}}

" Naviate Errors {{{
nnoremap <m-Down> :cnext<cr>
nnoremap <m-Up> :cprevious<cr>
" }}}

" {{{ Easy buffer navigation
noremap <C-h>  <C-w>h
noremap <C-j>  <C-w>j
noremap <C-k>  <C-w>k
noremap <C-l>  <C-w>l
noremap <leader>v <C-w>v
" }}}

" {{{ Replace
" Highlight current word and replace in entire file.
nnoremap <c-n> *:%s///g<left><left>
" }}}

nnoremap <m-c> :make<cr>

" Get an HTML representation of the current buffer including syntax
" highlighting.
let html_use_css=1
command! Tohtml runtime! syntax/2html.vim

" Highlight trailing whitespace in red.
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()


" Execute the given command in a shell and display the results in a new
" window. <M-r> in the new window will re-run the command that created
" the window. Each unique command gets its own window.
function! s:ExecuteInShell(command)
  let command = join(map(split(a:command), 'expand(v:val)'))
  let winnr = bufwinnr('^' . command . '$')
  silent! execute  winnr < 0 ? 'botright new ' . fnameescape(command) : winnr . 'wincmd w'
  setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap
  echo 'Execute ' . command . '...'
  silent! execute 'silent %!'. command
  silent! redraw
  silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
  silent! execute 'nnoremap <silent> <buffer> <C-r> :call <SID>ExecuteInShell(''' . command . ''')<CR>'
  silent! execute 'nnoremap <silent> <buffer> q :q<CR>'
  echo 'Shell command ' . command . ' executed.'
endfunction
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)

function! ExecuteCurrentLineInShell()
  let command = getline(line('.'))
  echo command
  execute ':call <SID>ExecuteInShell('''.command.''')'
endfunction

nnoremap <C-e> :call ExecuteCurrentLineInShell()<CR>

nnoremap ; :
set noeb vb t_vb=
